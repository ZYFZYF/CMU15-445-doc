# PROJECT #4 - CONCURRENCY CONTROL

## TASK #1 - LOCK MANAGER

### 设计理解

- 读写锁的实现
    - 维护目前正在读的数量ReadingCount、等待写的数量WaitingWriteCount、当前是否在写
    - （没必要维护等待读的数量以及正在写的数量，是否在写用来区分0读1写1等待写和0读2等待写的情况）
    - 读
        - 加锁：确保没有在写 -> 更新ReadingCount -> 获得读锁
        - 去锁：更新ReadingCount -> 如果变成0了，有写在等，唤醒
    - 写
        - 加锁：更新WaitingWriteCount -> 确保没有在写&也没有在读 -> 修改为当前在写 -> 获得写锁
        - 去锁：更新WaitingWriteCount -> 修改为当前不再写 -> 写读均可唤醒
    - 如果读写冲突时，写优先，1）那么去写锁的时候优先唤醒写，没有写了再唤醒读 2）读的时候也得确保没有写等待的任务

### 主要思路

- 针对三种隔离级别
    - 可重复读：用2PL即可（级联abort和幻读可能会出现），不用严格（这也是lock manager无法处理的）
    - 读提交：不用2PL，读完就可以释放
    - 读未提交：读不加锁
- 程序里只需要处理读写互斥的情况以及可重复读时的阶段即可
- 一些问题
    - 为什么不直接用C++提供的读写锁呢？
        - 锁升级，死锁不好判断
    - 如何在blocking的时候得知该事务被abort了？
        - 单个事务是单线程的，只会在等一个锁，然后为了避免死锁可能会被abort（被高优先级的txn abort掉）
- 死锁预防
    - Wait-die ： 老等新；新的abort（更好实现）
    - Wound-wait : 老抢新；新等老（作业让实现这个...增加难度）
        - 所以等待队列应当是从老到新，每次给下一个，队首持有写锁or队头的几个持有读锁
        - 写锁
            - 如果比有锁的更老，把他们abort后，成为队首，获得锁
            - 否则等着成为队首
        - 读锁
            - 比有锁的更老，而有锁的是写锁，那么abort后成为队首，获得锁，否则直接获得读锁
            - 否则等着成为队首
    - 都是老的优先（否则老的有可能饿死了）
    - 保证等待都是单向的，从而不会出现环
- （说实话在这个壳子里做填空题感觉思维总是会被限制，担心这个变量为啥要这样，我要怎么用上...）
- 我的思路是
    - 既然为了预防死锁，要做到有优先级，并且是wound-die，即老杀新，新等老
    - 也就是说等待的队列无需竞争，而是按照优先级顺序一个一个来即可（因此不用自带的读写锁）
    - 所以在LockRequestQueue中我们把所有请求按照优先级排序
    - 任何时刻队列呈以下两种状态之一
        - 队首持有写锁，其他位置等待
        - 对头的连续若干元素持有读锁，其他位置等待
    - 由于每个线程会被两种情况唤醒，abort / 可能获得锁，因此我们保存一个map<txn_id, cv>，每个事务阻塞在自己的cv里
    - 当有读锁插入时
        - 先找到它在queue中该在的位置，如果后面有写锁正在持有锁，把它abort
        - 等待
            - 被abort，删除，返回false
            - 处于队首 / 前一个读锁持有锁了，获得读锁，返回true
    - 当有写锁插入时
        - 先找到它在queue中该在的位置，如果后面有锁正在持有锁，把它abort
        - 等待
            - 被abort，删除，返回false
            - 处于队首，返回true
    - 当有读锁要升级时
        - 如果有另一个读锁也要升级，那么就永远不可能有任何一个升级成功，所以结束
        - 否则等待直到该读锁成为第一个持有读锁的，然后abort后面的读锁
            - 不用等到自己成为唯一的读锁，因为这就相当于老等新了，就会死锁
    - 释放锁的时候
        - 从list中删除元素
        - 为了简单处理，直接把前驱和后继都唤醒一下
    - 被abort的时候也要删除元素
        - 因为被abort的严格意义上就不算在等待的事务了，可能永远叫不醒
- 在之前的exectuor中上锁
    - 注意要对indexWriteSet进行更新即可（但update时接口有变，和autograder上不一样 或者 过不了safety check，可以省略掉）

### 经验教训

- 利用Autograder debug不太现实（我也不喜欢这种感觉...都不知道自己测的是什么东西...）
- 自己写好测试
    - 因为我是WoundWait测试全部超时， 所以我自己写了一个多个线程，对一堆rid（从事先定好的池子里随机挑）
    - 然后测试并发全读、并发全写、并发读写的情况下会不会死锁/超时
    - 实测并不会（本机无法开5000以上的线程）
- 注意一些特殊情况
    - 例如已经有读锁，再要写锁 / 已经有写锁，再要读锁 / 没有读锁，却要升级等等
- 用条件变量的时候尽量用引用传递，因为值传递后，引用变了，那边无法感知...
- 注意迭代器失效的问题
- 最confusing的一点
    - 如果老事务想上锁，队列中如果有只是在等待并没有获得锁的新事务请求，也要abort它，否则就会超时
    - 这和wound-wait算法说实话不符，而且效率理论上会很低？反复abort没有必要的事务

### 参考资料

- [c++读写锁-自实现 ](https://www.codeleading.com/article/72503848929/)
- [map/unordered_map with non-movable, default constructible value type](https://stackoverflow.com/questions/22229773/map-unordered-map-with-non-movable-default-constructible-value-type)